## habilitar routing host
echo "net.ipv4.ip_forward=1" | sudo tee /etc/sysctl.d/99-forward.conf
sudo sysctl --system

## Crear red docker dedicada 10.9.0.0 - conexion interna de servicios docker (ip estatica por servicio)
docker network create --driver bridge --subnet 10.9.0.0/24 iamantis_net

## crea rutas de openvpn hacia docker, editar server.conf de openvpn
## Edita /etc/openvpn/server/server.conf y añade:
# (tu config existente)
port 2394
proto udp
dev tun
topology subnet
server 10.8.0.0 255.255.255.0
# NUEVO: ruta para clientes VPN hacia Docker
push "route 10.9.0.0 255.255.255.0"
## reinicia openvpn
sudo systemctl restart openvpn-server@server || sudo systemctl restart openvpn

## cortafuegos y restricciones para que solo con VPN se alcancen los contenedores
# Permite tráfico desde la VPN (10.8.0.0/24) hacia contenedores (10.9.0.0/24)
sudo iptables -I DOCKER-USER -s 10.8.0.0/24 -d 10.9.0.0/24 -j ACCEPT
# Bloquea cualquier otro origen hacia la red de contenedores
sudo iptables -I DOCKER-USER -d 10.9.0.0/24 -j DROP
# Asegura retorno de conexiones establecidas
sudo iptables -I DOCKER-USER -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
## Usar DOCKER-USER es la práctica aconsejada para políticas adicionales.(Opcional: instala iptables-persistent para guardar reglas.)

## estructura de persistencia en disco y jerarquia de archivos
sudo mkdir -p /home/madrid/iamantis/{defectdojo/{mysql,redis,media},dependencytrack/data,sonarqube/{postgres,data,logs},zap/reports,jmeter/{tests,results},trivy/cache,gitleaks/{repos,reports},web,web/certbot,nginx/conf.d,certbot/{etc,lib}}
# Deja al usuario 'madrid' como dueño de todo
sudo chown -R madrid:madrid /home/madrid/iamantis
# Endurece permisos del directorio de certificados
sudo chmod 750 /home/madrid/iamantis/certbot/etc
# (cuando existan claves privadas, asegúrate de 600)
sudo find /home/madrid/iamantis/certbot/etc -type f -name "privkey.pem" -exec sudo chmod 600 {} \;
# (Opcional) crea un index mínimo para evitar 403/404 iniciales
sudo bash -c 'echo "<h1>Iamantis</h1>" > /home/madrid/iamantis/web/index.html'
sudo chown madrid:madrid /home/madrid/iamantis/web/index.html
## Docker recomienda bind mounts/volúmenes para persistencia; las cuotas no son nativas por volumen, de ahí el loopback opcional.

## configuración de docker-compose.yml
networks:
  iamantis_net:
    external: true
    name: iamantis_net

services:
  # ===================== DefectDojo: DB + Redis =====================
  postgres_ddj:
    image: postgres:15-alpine
    container_name: postgres_ddj
    restart: always
    environment:
      POSTGRES_DB: dojo
      POSTGRES_USER: iamantis
      POSTGRES_PASSWORD: 14m4nt15
    volumes:
      - /home/madrid/iamantis/defectdojo/postgres:/var/lib/postgresql/data
    networks:
      iamantis_net:
        ipv4_address: 10.9.0.10

  redis_ddj:
    image: redis:7-alpine
    container_name: redis_ddj
    restart: always
    volumes:
      - /home/madrid/iamantis/defectdojo/redis:/data
    networks:
      iamantis_net:
        ipv4_address: 10.9.0.11

  # ===================== DefectDojo (Django/uWSGI + Celery + Nginx UI) =====================
  defectdojo:
    image: defectdojo/defectdojo-django:latest
    container_name: defectdojo
    restart: always
    depends_on:
      - postgres_ddj
      - redis_ddj
    entrypoint: ["/entrypoint-uwsgi.sh"]
    environment:
      DD_SECRET_KEY: 14m4nt15
      DD_DATABASE_HOST: postgres_ddj
      DD_DATABASE_PORT: "5432"
      DD_DATABASE_NAME: dojo
      DD_DATABASE_USER: iamantis
      DD_DATABASE_PASSWORD: 14m4nt15
      DD_CELERY_BROKER_URL: redis://redis_ddj:6379/0
      DD_CELERY_RESULT_BACKEND: redis://redis_ddj:6379/1
    volumes:
      - /home/madrid/iamantis/defectdojo/extra_settings/local_settings.py:/app/docker/extra_settings/local_settings.py:ro
      - /home/madrid/iamantis/defectdojo/media:/app/media
      - /home/madrid/iamantis/defectdojo/reports:/app/reports
    networks:
      iamantis_net:
        ipv4_address: 10.9.0.12

  ddj_celeryworker:
    image: defectdojo/defectdojo-django:latest
    container_name: ddj_celeryworker
    restart: always
    depends_on:
      - defectdojo
    entrypoint: ["/entrypoint-celery-worker.sh"]
    environment:
      DD_CELERY_BROKER_URL: redis://redis_ddj:6379/0
      DD_CELERY_RESULT_BACKEND: redis://redis_ddj:6379/1
      DD_DATABASE_HOST: postgres_ddj
      DD_DATABASE_PORT: "5432"
      DD_DATABASE_NAME: dojo
      DD_DATABASE_USER: iamantis
      DD_DATABASE_PASSWORD: 14m4nt15
    volumes:
      - /home/madrid/iamantis/defectdojo/extra_settings/local_settings.py:/app/docker/extra_settings/local_settings.py:ro
    networks:
      iamantis_net:
        ipv4_address: 10.9.0.15

  ddj_celerybeat:
    image: defectdojo/defectdojo-django:latest
    container_name: ddj_celerybeat
    restart: always
    depends_on:
      - defectdojo
    entrypoint: ["/entrypoint-celery-beat.sh"]
    environment:
      DD_CELERY_BROKER_URL: redis://redis_ddj:6379/0
      DD_CELERY_RESULT_BACKEND: redis://redis_ddj:6379/1
      DD_DATABASE_HOST: postgres_ddj
      DD_DATABASE_PORT: "5432"
      DD_DATABASE_NAME: dojo
      DD_DATABASE_USER: iamantis
      DD_DATABASE_PASSWORD: 14m4nt15
    volumes:
      - /home/madrid/iamantis/defectdojo/extra_settings/local_settings.py:/app/docker/extra_settings/local_settings.py:ro
    networks:
      iamantis_net:
        ipv4_address: 10.9.0.16

  defectdojo_nginx:
    image: defectdojo/defectdojo-nginx:latest
    container_name: defectdojo_nginx
    restart: always
    depends_on:
      - defectdojo
    environment:
      DD_UWSGI_HOST: defectdojo
      DD_UWSGI_PORT: "3031"
    networks:
      iamantis_net:
        ipv4_address: 10.9.0.14
    # UI Dojo → publicado SOLO en la IP de la VPN
    ports:
      - "10.8.0.1:18080:8080"

  # ===================== Dependency-Track (bundled) =====================
  dependencytrack:
    image: dependencytrack/bundled:latest
    container_name: dependencytrack
    restart: always
    networks:
      iamantis_net:
        ipv4_address: 10.9.0.20
    ports:
      - "10.8.0.1:18020:8080"
    volumes:
      - /home/madrid/iamantis/dependencytrack/data:/data

  # ===================== SonarQube + PostgreSQL =====================
  postgres_sonar:
    image: postgres:15-alpine
    container_name: postgres_sonar
    restart: unless-stopped
    environment:
      POSTGRES_DB: sonar
      POSTGRES_USER: iamantis
      POSTGRES_PASSWORD: 14m4nt15
    volumes:
      - /home/madrid/iamantis/sonarqube/postgres:/var/lib/postgresql/data
    networks:
      iamantis_net:
        ipv4_address: 10.9.0.31
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U sonar -h 127.0.0.1 -d sonar || exit 1"]
      interval: 5s
      timeout: 3s
      retries: 20

  sonarqube:
    image: sonarqube:lts-community
    container_name: sonarqube
    restart: unless-stopped
    depends_on:
      - postgres_sonar
    environment:
      SONAR_JDBC_URL: jdbc:postgresql://postgres_sonar:5432/sonar
      SONAR_JDBC_USERNAME: iamantis
      SONAR_JDBC_PASSWORD: 14m4nt15
    volumes:
      - /home/madrid/iamantis/sonarqube/data:/opt/sonarqube/data
      - /home/madrid/iamantis/sonarqube/extensions:/opt/sonarqube/extensions
      - /home/madrid/iamantis/sonarqube/logs:/opt/sonarqube/logs
    networks:
      iamantis_net:
        ipv4_address: 10.9.0.30
    ports:
      - "10.8.0.1:19000:9000"

  # ===================== OWASP ZAP (daemon API) =====================
  zap:
    image: ghcr.io/zaproxy/zaproxy:stable
    container_name: zap
    restart: always
    command: >
      zap.sh -daemon
      -host 0.0.0.0 -port 8080
      -config api.disablekey=true
      -config api.addrs.addr.name=0.0.0.0
      -config api.addrs.addr.regex=true
    networks:
      iamantis_net:
        ipv4_address: 10.9.0.40
    ports:
      - "10.8.0.1:18081:8080"
    # Nota: este modo expone la API/proxy. Para una “web UI” completa usar zap-webswing (deprecated) u otra opción.

  # ===================== CLI tools (no exponen puertos) =====================
  gitleaks:
    image: zricethezav/gitleaks:latest
    container_name: gitleaks
    command: ["sleep", "infinity"]
    networks:
      iamantis_net:
        ipv4_address: 10.9.0.50
    volumes:
      - /home/madrid/iamantis/gitleaks:/work

  trivy:
    image: aquasec/trivy:latest
    container_name: trivy
    command: ["sleep", "infinity"]
    networks:
      iamantis_net:
        ipv4_address: 10.9.0.60
    volumes:
      - /home/madrid/iamantis/trivy:/work
      - /home/madrid/iamantis/trivy-cache:/root/.cache

  jmeter:
    image: justb4/jmeter:5.5
    container_name: jmeter
    command: ["sleep", "infinity"]
    networks:
      iamantis_net:
        ipv4_address: 10.9.0.70
    volumes:
      - /home/madrid/iamantis/jmeter:/test


## Hacer pull para lanzar los docker

cd /home/madrid/iamantis
## docker login    # opcional, ayuda con rate limits
docker compose pull --no-parallel
## sube y valida
docker compose up -d
docker compose ps
 ## para borrar contenedor
sudo docker rm -f nombrecontenedor

## Mientras tanto, con lo de arriba puedes levantar ya todo y entrar por VPN a:
DefectDojo → http://10.9.0.12:8080
Dependency-Track → http://10.9.0.20:8080
SonarQube → http://10.9.0.30:9000
ZAP API → http://10.9.0.40:8080
Trivy server → http://10.9.0.60:4954

## verificar conexion desde ubuntu
sudo docker ps -q | xargs -r -n1 sudo docker inspect -f '{{.Name}} -> {{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}'

## verificar red docker y bridge linux
# Inspecciona la red
sudo docker network inspect iamantis_net | grep -E 'Subnet|Gateway|com.docker.network.bridge.name' -A1 -n
 
 ## si tiene fallas con el bridge - leer bridge desde el docker para identificar, requiere root - sudo su
 # 1) Intenta leer el nombre del bridge directamente desde Docker
BR=$(docker network inspect iamantis_net -f '{{index .Options "com.docker.network.bridge.name"}}')
# 2) Si Docker no lo expone (valor vacío), constrúyelo con el ID de la red (br-<primeros 12 chars>)
if [ -z "$BR" ]; then
  NETID=$(docker network inspect iamantis_net -f '{{.Id}}' | cut -c1-12)
  BR="br-$NETID"
fi
echo "Bridge detectado: $BR"
# 3) Muestra datos útiles para confirmar
docker network inspect iamantis_net -f 'subnet={{(index .IPAM.Config 0).Subnet}} gw={{(index .IPAM.Config 0).Gateway}}'
ip addr show "$BR" | sed -n '1,10p'
# 4) (Opcional) Lista los contenedores conectados a esa red y sus IPs
docker network inspect iamantis_net -f '{{range .Containers}}{{println .Name "->" .IPv4Address}}{{end}}'


### luego de identificar el bridge br-xxxxxxxx se realiza la configuracion
## Prep del host (IP forwarding)
echo "net.ipv4.ip_forward=1" | sudo tee /etc/sysctl.d/99-forward.conf
sudo sysctl --system
## comprueba
sysctl net.ipv4.ip_forward   # debe devolver =1
## reinicia openvpn y reconecta clientes
sudo systemctl restart openvpn-server@server || sudo systemctl restart openvpn
## En el cliente VPN valida que aparece la ruta:
## Windows: route print | findstr 10.9.0.0
## Linux/macOS: ip route | grep 10.9.0.0/24

## iptables: permitir FORWARD entre tun0 y br-7adb8aab6639
## (a) Cadena FORWARD (núcleo del ruteo)
## esto permite el tráfico ida/vuelta entre la VPN y el bridge de Docker.
BR="br-7adb8aab6639"
# Permitir paso tun0 -> bridge y bridge -> tun0
sudo iptables -C FORWARD -i tun0 -o $BR -j ACCEPT 2>/dev/null || sudo iptables -I FORWARD -i tun0 -o $BR -j ACCEPT
sudo iptables -C FORWARD -i $BR -o tun0 -j ACCEPT 2>/dev/null || sudo iptables -I FORWARD -i $BR -o tun0 -j ACCEPT

## Pruebas de conectividad
## subir solo 1 servicio de defectdojo
sudo docker compose up -d defectdojo_nginx
## verificar que este corriendo
sudo docker ps --format "table {{.Names}}\t{{.Ports}}"
## confirmar que el puerto esta escuchando
sudo ss -tulpn | grep 18080
## probar servicio en el vps ubuntu 
curl -I http://10.8.0.1:18080
## probar desde powershell en windows
curl.exe -I http://10.8.0.1:18080
## revisar que esten en la misma red
sudo docker inspect dependencytrack | grep '"NetworkMode"'
sudo docker inspect postgres_ddj | grep '"NetworkMode"'
## revisar IP de cada uno
sudo docker inspect -f '{{.NetworkSettings.Networks.iamantis_net.IPAddress}}' dependencytrack
sudo docker inspect -f '{{.NetworkSettings.Networks.iamantis_net.IPAddress}}' postgres_ddj
## confirmar que tiene variables correctas
sudo docker inspect dependencytrack | grep ALPINE_DATABASE
## iniciar solo el contenedor que se requiere del compose
sudo docker compose up -d dependencytrack
## probar conexion manual con el contenedor
sudo docker exec -it dependencytrack sh
apk add --no-cache postgresql-client
psql -h postgres_ddj -U iamantis -d dependencytrack -c '\conninfo'
## monitoreo de procesamiento y memoria de los contenedores
sudo docker stats dependencytrack
## revisar salud del contenedor
sudo docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

